<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="utf-8" /> 
    <title>MSCWeb</title> 
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.6.1.min.js"></script>
    <script type="text/javascript" src="d3.js"></script>
    <style>
        body {
            margin: 0px;
        }
        #mscheader {
            position: fixed;
            height: 65px;
            top: 0px;
            left: 0px;
            width: 100%;
            background-color: #000033;
        }
        #msccontain {
            position: absolute;
            width: 100%;
            top: 65px;
            bottom: 0px;
            overflow: auto;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            height: 50px;
            width: 120px;
            background-color: #cccccc;
            border: 1px solid black;
            box-shadow: 0 1px 15px rgba(0,0,0,0.75);
        }
        #headercanvas {
            width: 900px;
            height: 65px;
        }
        #maincanvas {
            width: 900px;
            height: 600px;
        }

        #hover {
            background-color: #ccccff;
            width: 200px;
            height: 100px;
            bottom: 20px;
            right: 20px;
            display: none;
            position: absolute;
            z-index: 10;
            overflow: auto;
            box-shadow: 0 1px 15px rgba(0,0,0,0.75);
        }
    </style>
</head>
<body>
    <div id="mscheader">
        <div id="headercanvas">
            <svg id="headersvg" width="900" height="100" />
        </div>
    </div>
    <div id="hover"></div>
    <div id="msccontain">
        <div id="maincanvas">
            <svg id="mainsvg" width="900" height="600">
                <defs>
                    <marker id="rpcreq" viewBox="0 0 10 20" refX=10 refY=10 markerUnits="strokeWidth" orient="auto" markerWidth=10 markerHeight=10>
                        <polyline points="0,0 10,10 0,20" fill="#000000" />
                    </marker>
                    <marker id="rpcres" viewBox="0 0 10 20" refX=10 refY=10 markerUnits="strokeWidth" orient="auto" markerWidth=10 markerHeight=10>
                        <polyline points="0,0 10,10 0,20" fill="#999999" />
                    </marker>
                    <marker id="data" viewBox="0 0 10 20" refX=10 refY=10 markerUnits="strokeWidth" orient="auto" markerWidth=10 markerHeight=10>
                        <polyline points="0,0 10,10 0,20" fill="#0000ff" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>
    <div id="controls">
        <!--<button name="getlive" type="button" value="getlive">get live (debug)</button>-->
        <button name="flowcontrol" type="button" value="live">Start</button>
        <br/>
        <input id="scrollondata" name="scrollondata" type="checkbox" checked="checked" value="Scroll on new data" />
        <label for="scrollondata" name="lbl_scrollondata">Autoscroll</label>
    </div>

    <script type="text/javascript">
        var gheaders = [];  // group headers
        var headers={};     // associative array groupheader->[] of subheaders
        var data = [];

        var cheader;
        var cmain;
        var curheight = 600;
        var curwidth = 900;
        var curheads = 0;

        function getnames(x) {
            var sidx = x.indexOf("/");
            if (sidx == -1) 
                return { gname: "None", name: x };
             else 
                 return { gname: x.slice(0, sidx), name: x.slice(sidx+1) };
        }

        function doheaders(indata) {
            var dirty = 0;
            $.each(indata, function(i, d) {

                function addunknown(x) {
                    slices = getnames(x);
                    gname = slices.gname;
                    name = slices.name;

                    if ($.inArray(gname, $.map(gheaders, function(el, idx) { return el.name; })) == -1) {
                        gheaders.push({name:gname, collapsed:true, hidden:false});
                        headers[gname] = [];
                        gheaders.sort(function(a, b) {
                            a = a.name.toLowerCase();
                            b = b.name.toLowerCase();
                            if (a < b) return -1;
                            if (a > b) return 1;
                            return 0;
                        });
                    }

                    if ($.inArray(name, $.map(headers[gname], function(el,idx) { return el.name; })) == -1) {
                        dirty += 1;
                        headers[gname].push({name:name, hidden:false});
                        headers[gname].sort(function(a, b) {
                            a = a.name.toLowerCase();
                            b = b.name.toLowerCase();
                            if (a < b) return -1;
                            if (a > b) return 1;
                            return 0;
                        });
                    }
                }

                if (d.type != "event")
                    addunknown(d.to);
                addunknown(d.from);
            });

            //console.log(gheaders);
            //console.log(headers.datastore);

            return dirty;
        }

        function drawheaders()
        {
            // first, group headers
            //console.log(gheaders);
            var gheads = cheader.selectAll("g.gheader")
                .data(gheaders, function(d) { return d.name; } );

            function getgroupxoffset(d, i) {
                var x, y = 0;
                // x is the sum of the previous headers' children size
                var icount = 0;
                for (var i = 0; i < gheaders.indexOf(d); i++)
                {
                    if (gheaders[i].hidden)
                        icount += 0;
                    else if (gheaders[i].collapsed)
                        icount += 1;
                    else
                        icount += headers[gheaders[i].name].length;
                }

                x = icount * 150;

                return "translate(" + x + "," + y + ")";
            }

            // update current ones
            gheads.transition()
                .duration(500)
                .attr("transform", getgroupxoffset)
                .attr("width", function(d, i) {
                    if (d.collapsed)
                        return 150;
                    else
                        return headers[d.name].length * 150;
                });
            gheads.selectAll(".grect").transition()
                .duration(500)
                .attr("width", function(d) {
                    if (d.collapsed)
                        return 150 - 10;
                    else
                        return headers[d.name].length * 150 - 10;
                });

            gheads.selectAll(".gtext").transition()
                .duration(500)
                .attr("x", function(d) { 
                    if (d.collapsed)
                        return 150 / 2;
                    else
                        return headers[d.name].length * 150 / 2; 
                });

            // create new ones
            var newgheads = gheads.enter().append("svg:g")
                .attr("id", function(d) { return d.name; })
                .attr("class", "gheader")
                .attr("transform", getgroupxoffset)
                .attr("width", function(d, i) {
                    if (d.collapsed)
                        return 150;
                    else
                        return headers[d.name].length * 150;
                })
                .attr("height", 50)
                .attr("fill", "#ff0000");

            // no need to delete
            // @TODO HIDDEN WILL NEED TO DELETE

            $('g.gheader').unbind('click').click(function(e) {
                headname = $(this).attr('id')
                for (var i = 0; i < gheaders.length; i++)
                    if (gheaders[i].name == headname)
                    {
                        gheaders[i].collapsed = !gheaders[i].collapsed;
                        break;
                    }


                redraw([]);
            });

            // create rects/texts on any new items
            newgheads.append("svg:rect")
                .attr("class", "grect")
                .attr("fill", "#336699")
                .attr("x", 5)
                .attr("y", 5)
                .attr("width", function(d, i) {
                    if (d.collapsed)
                        return 150 - 10;
                    else
                        return headers[d.name].length * 150 - 10;
                })
                .attr("height", 25);
 
            newgheads.append("svg:text")
                .attr("class", "gtext")
                .attr("fill", "white")
                .attr("x", function(d) {
                    if (d.collapsed)
                        return 150 / 2;
                    else
                        return headers[d.name].length * 150 / 2; 
                })
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .text(function(d) { return d.name; });

            // now draw subheaders
            cheader.selectAll('.gheader').each(function (d, i) {

                var heads = d3.select(this).selectAll('.subhead');
                var sheads;
                if (d.collapsed)
                    sheads = heads.data([{name:"(" + headers[d.name].length + " items)"}], function(dx) { return dx.name; });
                else
                    sheads = heads.data(headers[d.name], function(dx) { return dx.name; })

                function getsubxoffset(d, i) {
                    var x, y = 30;
                    x = i * 150;
                    return "translate(" + x + "," + y + ")";
                }

                // update existing
                sheads
                    .attr('id', function(d) { return d.name; })
                    .transition()
                    .duration(500)
                    .attr("transform", getsubxoffset);

                sheads.selectAll('text')
                    .text(function(d) { return d.name });

                // append new ones
                var newsubheads = sheads.enter().append("svg:g")
                    .attr("id", function(d) { return d.name; })
                    .attr("class", "subhead")
                    .attr("transform", getsubxoffset)
                    .attr("opacity", 0);

                newsubheads.transition()
                    .delay(250)
                    .duration(500)
                    .attr("opacity", 1); 

                newsubheads.append("svg:rect")
                    .attr("x", 5)
                    .attr("y", 5)
                    .attr("width", 140)
                    .attr("height", 25)
                    .attr("fill", "#3696ef");

                newsubheads.append("svg:text")
                    .attr("x", 75)
                    .attr("y", 20)
                    .attr("fill", "white")
                    .attr("text-anchor", "middle")
                    .text(function(d) { return d.name });

                // remove old ones (recently collapsed)
                sheads.exit().remove();
            });

            // now draw lines on main doc

            // assemble the current data in sorted form
            linedata = [];
            $.each(gheaders, function(i, d) {
                if (!d.hidden)
                {
                    if (d.collapsed)
                        linedata.push("line_" + d.name);
                    else
                    {
                        $.each(headers[d.name], function(ii, dd) {
                            linedata.push("line_" + d.name + "_" + dd.name);
                        });
                    }
                }
            });

            var msclines = cmain.selectAll("line.proc")
                .data(linedata, function(d) { return d; });

            // update
            var rettrans = msclines/*.transition()
                .duration(500)*/
                .attr("x1", function(d, i) { return i * 150 + 75; })
                .attr("x2", function(d, i) { return i * 150 + 75; });

            msclines.enter().append("svg:line")
                .attr("id", function(d) { return d; })
                .attr("class", "proc")
                .attr("x1", function(d, i) { return i * 150 + 75; })
                .attr("y1", 0)
                .attr("x2", function(d, i) { return i * 150 + 75; })
                .attr("y2", curheight)
                .attr("stroke", "#999")
                .attr("stroke-dasharray", "2, 2");

            // remove dead ones
            msclines.exit().remove();

            return rettrans;    // so we can chain off of this
        }

        function drawdata() {
            
            var dlines = cmain.selectAll("g.msg")
                .data(data);    // index is fine

            function getlinex(rawid) {
              splits = getnames(rawid);
              var collapsed = false;
              for (var i = 0; i < gheaders.length; i++)
              {
                if (gheaders[i].name == splits.gname) {
                  collapsed = gheaders[i].collapsed;
                  break;
                }
              }

              if (collapsed)
                  lid = "line_" + splits.gname;
              else
                  lid = "line_" + splits.gname + "_" + splits.name;

              return cmain.select("line#" + lid).attr("x1");
            }

            // update existing 
            dlines.selectAll(".dataline").transition()
                .duration(500)
                .attr("x1", function(d) { return getlinex(d.from) })
                .attr("x2", function(d) { return getlinex(d.to) });

            dlines.selectAll(".datatext").transition()
                .duration(500)
                .attr("x", function(d) { return (parseInt(getlinex(d.from)) + parseInt(getlinex(d.to))) / 2; } );

            dlines.selectAll(".dataevent").transition()
                .duration(500)
                .attr("x", function(d) { return getlinex(d.from) - 75; });

            dlines.selectAll(".eventtext").transition()
                .duration(500)
                .attr("x", function(d) { return getlinex(d.from); });

            // create new ones
            var newdatas = dlines.enter().append("svg:g")
                //.attr("style", "text-shadow: 0px 0px 5px #fff;")
                .attr("data-to", "spiffy")
                .attr("class", "msg")
                .attr("opacity", 0);
                
            newdatas.transition()
                .duration(500)
                .attr("opacity", 1);

            var noevdatas = newdatas.filter(function(d) { return d.type != "event"; });

            noevdatas.append("svg:line")
                .attr("class", "dataline")
                .attr("stroke", "#666")
                .attr("x1", function(d, i) { return getlinex(d.from); })
                .attr("y1", function(d, i) { return 30 * d.idx + 10; })
                .attr("x2", function(d, i) { return getlinex(d.to); })
                .attr("y2", function(d, i) { return 30 * d.idx + 10; })
                .attr("stroke-width", 2)
                .attr("marker-end", function(d) { return "url(#" + d.type + ")"; } )
                .attr("stroke-dasharray", function(d) {
                    if (d.type == "rpcreq")
                        return "none";
                    else if (d.type == "data")
                        return "5, 2";
                    else
                        return "2, 2";
                });

            noevdatas.append("svg:text")
                .attr("class", "datatext")
                .attr("fill", "#000")
                .attr("data-full", function(d, i) { return d.content; })
                //.attr("stroke", "#fff")
                //.attr("stroke-width", 15)
                .attr("x", function(d, i) { return (parseInt(getlinex(d.from)) + parseInt(getlinex(d.to))) / 2; } )
                .attr("y", function(d, i) { return 30 * d.idx + 8; })
                .attr("text-anchor", "middle")
                .text(function(d) { return d.topline; });

            var evdatas = newdatas.filter(function(d) { return d.type == "event"; });
            
            evdatas.append("svg:rect")
                .attr("class", "dataevent")
                .attr("stroke", "#666")
                .attr("fill", "#ffcc33")
                .attr("data-full", function(d, i) { return d.content; })
                .attr("x", function(d, i) { return getlinex(d.from) - 75; })
                .attr("y", function(d, i) { return 30 * d.idx; })
                .attr("width", 150)
                .attr("height", 20)
                .attr("stroke-width", 2);

            evdatas.append("svg:text")
                .attr("class", "eventtext")
                .attr("fill", "#000")
                .attr("x", function(d, i) { return getlinex(d.from); })
                .attr("y", function(d, i) { return 30 * d.idx + 12; })
                .attr("text-anchor", "middle")
                .text(function(d) { return d.topline; });

            $('g.msg').unbind('mouseover').mouseover(function(e) {
                $('#hover').text($('[data-full]', this).attr('data-full'));
                //$('#hover').offset({top:e.pageX - 10, left: e.pageY - 100});
                $('#hover').css({display:'block', left:e.pageX - 100, top:e.pageY + 20});
            });
            $('g.msg').unbind('mouseout').mouseout(function(e) {
                $('#hover').css({display:'none'});
            });
        }

        $(function() {
            // setup errything
            cheader = d3.select('#headercanvas').select('svg');
            cmain = d3.select('#maincanvas').select('svg');
            
            $("button[name='getlive']").click(function() {
                get_live_data(false);
            });

            $("button[name='flowcontrol']").click(function() {
                if ($(this).text() == "Stop")
                {
                    window.clearTimeout(intervalID);
                    $(this).text('Start');
                }
                else
                {
                    get_live_data(true);
                    $(this).text('Stop');
                }
            });
        });

        var intervalID;

        function get_live_data(reschedule)
        {
            console.log('get_live_data');
            $.getJSON('/data/', function(newdata) {
                //console.log(newdata);
                console.log("Retrieved " + newdata.length + " new elements.");

                for (var i = 0; i < newdata.length; i++)
                {
                    newdata[i].idx = data.length;
                    data.push(newdata[i]);
                }
                redraw(newdata);
                if ($("input[name='scrollondata']").attr('checked') == 'checked' && newdata.length > 0)
                    $('#msccontain').scrollTop($('#msccontain').attr('height'));

                if (reschedule == true)
                    intervalID = window.setTimeout(get_live_data, 2000, true);
            });
        }
        
        function resize_svgs()
        {
            headcount = 0;
            $.each(gheaders, function(idx, el) { 
                if (!el.hidden)
                    if (el.collapsed)
                        headcount+=1;
                    else
                        headcount += headers[el.name].length;
            });

            // resize svg if we need to
            if (headcount * 150 > curwidth) {
                curwidth = headcount * 150;
                $("#msccontain,#mscheader,svg").attr("width", curwidth);
                console.log("tried to resize");
            }

            if (data.length * 30 + 10 > curheight) {
                curheight = data.length * 30 + 10;
                $('#msccontain, #msccontain svg').attr('height', curheight);
                console.log("tried to resize vert");

                var msclines = cmain.selectAll("line.proc");
                msclines.attr('y2', curheight);
            }

        }

        function redraw(newdata, force)
        {
            var trans = null;
            var dirty = doheaders(newdata);

            curheads += dirty;
            //console.log("currently " + curheads);

            // resize
            resize_svgs();

            trans = drawheaders();

            // anim is too annoying, don't bother
            drawdata();
        }

        $(function() {
            $('#msccontain').scroll(function() {
                ls = $(this).scrollLeft();
                //console.log($(this).scrollLeft());
                $('#headercanvas').offset({ top:0, left: 0 - ls});
            });
        });

        $(function() { redraw(data, true); });
    </script>
</body>
</html>
