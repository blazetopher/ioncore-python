<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="utf-8" /> 
    <title>mwap</title> 
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.6.1.min.js"></script>
    <script type="text/javascript" src="d3.js"></script>
    <style>
        body {
            margin: 0px;
        }
        #mscheader {
            position: fixed;
            height: 65px;
            top: 0px;
            left: 0px;
            width: 100%;
            background-color: #000033;
        }
        #msccontain {
            position: absolute;
            width: 100%;
            top: 65px;
            bottom: 0px;
            overflow: auto;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            height: 50px;
            width: 120px;
            background-color: #cccccc;
            border: 1px solid black;
            box-shadow: 0 1px 15px rgba(0,0,0,0.75);
        }
        #headercanvas {
            width: 900px;
            height: 65px;
        }
        #maincanvas {
            width: 900px;
            height: 600px;
        }

    </style>
</head>
<body>
    <div id="mscheader">
        <div id="headercanvas">
            <svg id="headersvg" width="900" height="100" />
        </div>
    </div>
    <div id="msccontain">
        <div id="maincanvas">
            <svg id="mainsvg" width="900" height="600">
                <defs>
                    <marker id="rpcreq" viewBox="0 0 10 20" refX=10 refY=10 markerUnits="strokeWidth" orient="auto" markerWidth=10 markerHeight=10>
                        <polyline points="0,0 10,10 0,20" fill="#000000" />
                    </marker>
                    <marker id="rpcres" viewBox="0 0 10 20" refX=10 refY=10 markerUnits="strokeWidth" orient="auto" markerWidth=10 markerHeight=10>
                        <polyline points="0,0 10,10 0,20" fill="#999999" />
                    </marker>
                    <marker id="data" viewBox="0 0 10 20" refX=10 refY=10 markerUnits="strokeWidth" orient="auto" markerWidth=10 markerHeight=10>
                        <polyline points="0,0 10,10 0,20" fill="#0000ff" />
                    </marker>
                </defs>
            </svg>
        </div>
    </div>
    <div id="controls">
        <!--<button name="getlive" type="button" value="getlive">get live (debug)</button>-->
        <button name="flowcontrol" type="button" value="live">Start</button>
        <br/>
        <input id="scrollondata" name="scrollondata" type="checkbox" checked="checked" value="Scroll on new data" />
        <label for="scrollondata" name="lbl_scrollondata">Autoscroll</label>
    </div>

    <script type="text/javascript">
        var gheaders = [];  // group headers
        var headers={};     // associative array groupheader->[] of subheaders
        var data = [];

        var cheader;
        var cmain;
        var curheight = 600;
        var curwidth = 900;
        var curheads = 0;

        function getnames(x) {
            var sidx = x.indexOf("/");
            if (sidx == -1) 
                return { gname: "None", name: x };
             else 
                 return { gname: x.slice(0, sidx), name: x.slice(sidx+1) };
        }

        function doheaders(indata) {
            var dirty = 0;
            $.each(indata, function(i, d) {

                function addunknown(x) {
                    slices = getnames(x);
                    gname = slices.gname;
                    name = slices.name;

                    if ($.inArray(gname, gheaders) == -1) {
                        gheaders.push(gname);
                        headers[gname] = [];
                        gheaders.sort();
                    }

                    if ($.inArray(name, headers[gname]) == -1) {
                        dirty += 1;
                        headers[gname].push(name);
                        headers[gname].sort();
                    }
                }

                if (d.type != "event")
                    addunknown(d.to);
                addunknown(d.from);
            });

            //console.log(gheaders);
            //console.log(headers.datastore);

            return dirty;
        }

        function drawheaders()
        {
            // first, group headers
            var gheads = cheader.selectAll("g.gheader")
                .data(gheaders, function(d) { return d; } );

            function getgroupxoffset(d, i) {
                var x, y = 0;
                // x is the sum of the previous headers' children size
                var icount = 0;
                for (var i = 0; i < gheaders.indexOf(d); i++)
                    icount += headers[gheaders[i]].length;

                x = icount * 150;

                return "translate(" + x + "," + y + ")";
            }

            // update current ones
            gheads.transition()
                .duration(500)
                .attr("transform", getgroupxoffset)
                .attr("width", function(d, i) {
                    return headers[d].length * 150;
                });
            gheads.selectAll(".grect").transition()
                .duration(500)
                .attr("width", function(d) {
                    return headers[d].length * 150 - 10;
                })
            gheads.selectAll(".gtext").transition()
                .duration(500)
                .attr("x", function(d) { return headers[d].length * 150 / 2; });

            // create new ones
            var newgheads = gheads.enter().append("svg:g")
                .attr("id", function(d) { return d; })
                .attr("class", "gheader")
                .attr("transform", getgroupxoffset)
                .attr("width", function(d, i) {
                    return headers[d].length * 150;
                })
                .attr("height", 50)
                .attr("fill", "#ff0000");

            // no need to delete

            // create rects/texts on any new items
            newgheads.append("svg:rect")
                .attr("class", "grect")
                .attr("fill", "#336699")
                .attr("x", 5)
                .attr("y", 5)
                .attr("width", function(d, i) {
                    return headers[d].length * 150 - 10;
                })
                .attr("height", 25);
 
            newgheads.append("svg:text")
                .attr("class", "gtext")
                .attr("fill", "white")
                .attr("x", function(d) { return headers[d].length * 150 / 2; })
                .attr("y", 20)
                .attr("text-anchor", "middle")
                .text(function(d) { return d });

            // now draw subheaders
            cheader.selectAll('.gheader').each(function (d, i) {

                var sheads = d3.select(this).selectAll('.header')
                    .data(headers[d], function(dx) { return dx; })

                function getsubxoffset(d, i) {
                    var x, y = 30;
                    x = i * 150;
                    return "translate(" + x + "," + y + ")";
                }

                // update existing
                sheads.transition()
                    .duration(500)
                    .attr("transform", getsubxoffset);

                var newsubheads = sheads.enter().append("svg:g")
                    .attr("id", function(d) { return d; })
                    .attr("class", "subhead")
                    .attr("transform", getsubxoffset)
                    .attr("opacity", 0);

                newsubheads.transition()
                    .delay(250)
                    .duration(500)
                    .attr("opacity", 1); 

                newsubheads.append("svg:rect")
                    .attr("x", 5)
                    .attr("y", 5)
                    .attr("width", 140)
                    .attr("height", 25)
                    .attr("fill", "#3696ef");

                newsubheads.append("svg:text")
                    .attr("x", 75)
                    .attr("y", 20)
                    .attr("fill", "white")
                    .attr("text-anchor", "middle")
                    .text(function(d) { return d });
            });

            // now draw lines on main doc

            // assemble the current data in sorted form
            linedata = [];
            $.each(gheaders, function(i, d) {
                $.each(headers[d], function(ii, dd) {
                    linedata.push(d + "_" + dd);
                });
            });

            var msclines = cmain.selectAll("line.proc")
                .data(linedata, function(d) { return d; });

            // update
            var rettrans = msclines.transition()
                .duration(500)
                .attr("x1", function(d, i) { return i * 150 + 75; })
                .attr("x2", function(d, i) { return i * 150 + 75; });

            msclines.enter().append("svg:line")
                .attr("id", function(d) { return d; })
                .attr("class", "proc")
                .attr("x1", function(d, i) { return i * 150 + 75; })
                .attr("y1", 0)
                .attr("x2", function(d, i) { return i * 150 + 75; })
                .attr("y2", curheight)
                .attr("stroke", "#999")
                .attr("stroke-dasharray", "2, 2");

            return rettrans;    // so we can chain off of this
        }

        function drawdata() {
            
            var dlines = cmain.selectAll("g.msg")
                .data(data);    // index is fine

            function getlinex(rawid) {
              splits = getnames(rawid);
              lid = splits.gname + "_" + splits.name;
              return cmain.select("#" + lid).attr("x1");
            }

            // update existing 
            dlines.selectAll(".dataline").transition()
                .duration(500)
                .attr("x1", function(d) { return getlinex(d.from) })
                .attr("x2", function(d) { return getlinex(d.to) });

            dlines.selectAll(".datatext").transition()
                .duration(500)
                .attr("x", function(d) { return (parseInt(getlinex(d.from)) + parseInt(getlinex(d.to))) / 2; } );

            dlines.selectAll(".dataevent").transition()
                .duration(500)
                .attr("x", function(d) { return getlinex(d.from) - 75; });

            dlines.selectAll(".eventtext").transition()
                .duration(500)
                .attr("x", function(d) { return getlinex(d.from); });

            // create new ones
            var newdatas = dlines.enter().append("svg:g")
                //.attr("style", "text-shadow: 0px 0px 5px #fff;")
                .attr("class", "msg")
                .attr("opacity", 0);
                
            newdatas.transition()
                .duration(500)
                .attr("opacity", 1);

            function noevents(d, i) {
                return d.type != "event";
            }

            newdatas.filter(noevents).append("svg:line")
                .attr("class", "dataline")
                .attr("stroke", "#666")
                .attr("x1", function(d, i) { return getlinex(d.from); })
                .attr("y1", function(d, i) { return 30 * d.idx + 10; })
                .attr("x2", function(d, i) { return getlinex(d.to); })
                .attr("y2", function(d, i) { return 30 * d.idx + 10; })
                .attr("stroke-width", 2)
                .attr("marker-end", function(d) { return "url(#" + d.type + ")"; } )
                .attr("stroke-dasharray", function(d) {
                    if (d.type == "rpcreq")
                        return "none";
                    else if (d.type == "data")
                        return "5, 2";
                    else
                        return "2, 2";
                });

            newdatas.filter(noevents).append("svg:text")
                .attr("class", "datatext")
                .attr("fill", "#000")
                //.attr("stroke", "#fff")
                //.attr("stroke-width", 15)
                .attr("x", function(d, i) { return (parseInt(getlinex(d.from)) + parseInt(getlinex(d.to))) / 2; } )
                .attr("y", function(d, i) { return 30 * d.idx + 8; })
                .attr("text-anchor", "middle")
                .text(function(d) { return d.content; });

            function onlyevents(d, i) {
                return d.type == "event";
            }

            newdatas.filter(onlyevents).append("svg:rect")
                .attr("class", "dataevent")
                .attr("stroke", "#666")
                .attr("fill", "#ffcc33")
                .attr("x", function(d, i) { return getlinex(d.from) - 75; })
                .attr("y", function(d, i) { return 30 * d.idx; })
                .attr("width", 150)
                .attr("height", 20)
                .attr("stroke-width", 2);

            newdatas.filter(onlyevents).append("svg:text")
                .attr("class", "eventtext")
                .attr("fill", "#000")
                .attr("x", function(d, i) { return getlinex(d.from); })
                .attr("y", function(d, i) { return 30 * d.idx + 12; })
                .attr("text-anchor", "middle")
                .text(function(d) { return d.content; });
        }

        $(function() {
            // setup errything
            cheader = d3.select('#headercanvas').select('svg');
            cmain = d3.select('#maincanvas').select('svg');
            
            $("button[name='getlive']").click(function() {
                get_live_data(false);
            });

            $("button[name='flowcontrol']").click(function() {
                if ($(this).text() == "Stop")
                {
                    window.clearTimeout(intervalID);
                    $(this).text('Start');
                }
                else
                {
                    get_live_data(true);
                    $(this).text('Stop');
                }
            });

        });

        var intervalID;

        function get_live_data(reschedule)
        {
            console.log('get_live_data');
            $.getJSON('/data/', function(newdata) {
                //console.log(newdata);
                console.log("Retrieved " + newdata.length + " new elements.");

                for (var i = 0; i < newdata.length; i++)
                {
                    newdata[i].idx = data.length;
                    data.push(newdata[i]);
                }
                redraw(newdata);
                if ($("input[name='scrollondata']").attr('checked') == 'checked' && newdata.length > 0)
                    $('#msccontain').scrollTop($('#msccontain').attr('height'));

                if (reschedule == true)
                    intervalID = window.setTimeout(get_live_data, 2000, true);
            });
        }

        function redraw(newdata, force)
        {
            if (!force)
                force = false;

            var trans = null;
            var dirty = doheaders(newdata);

            curheads += dirty;
            //console.log("currently " + curheads);

            // resize svg if we need to
            if (curheads * 150 > curwidth) {
                curwidth = curheads * 150;
                $("#msccontain,#mscheader,svg").attr("width", curwidth);
                console.log("tried to resize");
            }

            if (data.length * 30 + 10 > curheight) {
                curheight = data.length * 30 + 10;
                $('#msccontain, #msccontain svg').attr('height', curheight);
                console.log("tried to resize vert");

                var msclines = cmain.selectAll("line.proc");
                msclines.attr('y2', curheight);
            }

            if (dirty != 0)
                trans = drawheaders();

            // we only wait if were dirty and not forced
            if (dirty != 0 && !force)
            {
                var callonce = false;
                trans.each("end", function() {
                    if (!callonce) {
                        callonce = true;
                        drawdata();
                    }
                });
            }
            else
                drawdata();
        }

        $(function() {
            $('#msccontain').scroll(function() {
                ls = $(this).scrollLeft();
                //console.log($(this).scrollLeft());
                $('#headercanvas').offset({ top:0, left: 0 - ls});
            });
        });

        $(function() { redraw(data, true); });
    </script>
</body>
</html>
